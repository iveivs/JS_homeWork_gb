// Объект робот-пылесос.
const Roomba = { // Есть негласное правило называть объекты в
    // алгоритмах с большой буквы.
    // Обычно сначала объявляют свойства объекта.
    model: "Romba-1",
    power: 200,
    batterySize: 2100,
    boxSize: 0.5,
    workTime: 45,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // После свойств объявляют его методы.
    startCleaning: function () {
        this.counterOfStarts++;
        console.log('I am cleaning... I have been started: ',
            this.counterOfStarts, 'times.', this.model);
    },
    goCharge: function () {
        console.log('I am going to charge...');
    },
    switchUVLamp: function () {
        this.isUVLampOn = !this.isUVLampOn;
        console.log(`UV lamp is ${this.isUVLampOn ? 'working' :
            'not working'}.`);
    }
};

// Roomba.startCleaning()
// Roomba.startCleaning()


// Одалживание метода
const Tango = { 
    model: "Tango-1",
    power: 300,
    batterySize: 3200,
    boxSize: 0.7,
    workTime: 60,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // После свойств объявляют его методы. А так как методы у
    // новой модели такие же как и у старой, давайте позаимствуем их у объекта Roomba.
    startCleaning: Roomba.startCleaning,
    goCharge: Roomba.goCharge,
    switchUVLamp: Roomba.switchUVLamp,
};

Tango.startCleaning()

// Объект робот-пылесос модель Samba.
const Samba = {
    model: "Samba-1",
    power: 250,
    batterySize: 2500,
    boxSize: 0.5,
    workTime: 50,
    counterOfStarts: 0,
    isFull: false,
    isObstacle: false,
    isUVLampOn: false,
    // На этот раз мы не будем создавать методы в объекте, мы
    // постараемся их заимствовать непосредственно перед использованием.
};
// Одолжим методы из объекта Roomba.
Samba.startCleaning = Roomba.startCleaning;
Samba.switchUVLamp = Roomba.switchUVLamp;
Samba.goCharge = Roomba.goCharge;

// Samba.goCharge(); // 'I am going to charge...'


setTimeout(Roomba.startCleaning, 1000) // I am cleaning... I have been started:  NaN times. undefined (не работает отображение кол-ва запусков и название модели)

// setTimeout(Roomba.switchUVLamp, 2000);
// setTimeout(Roomba.switchUVLamp, 2000); // не переключается


// Мы получили немного странный результат. Количество запусков пылесоса стало NaN, 
// а ультрафиолетовая лампа не выключилась. Почему это произошло, давайте разбираться. 

// Когда мы вызывали методы объекта напрямую, после его создания,

// функция вызывалась имея возможность получить доступ к объекту, но когда

// функция вызывается внутри метода setTimeout, то эта функция теряет доступ к

// своему объекту, и ключевое слово this в такой функции получает значение

// undefined. Вот тут и вступает в игру контекст вызова функции. Каждая функция

// вызывается в контексте некоторого объекта, если эта функция определена вне

// какого-то пользовательского объекта, то её контекстом будет глобальный объект
// (например window в браузере), а если определена в пользовательском объекте, и
// вызвана в нём, то контекстом для неё будет этот пользовательский объект. Когда же
// мы вызываем функцию в отрыве от её объекта, как это происходит при вызове её из
// setTimeout, то её контекстом становится undefined. Так происходит потому, что мы
// одалживаем метод у объекта, и функция setTimeout копирует нашу функцию, для
// того чтобы вызвать её позже, но когда она вызывается доступа к объекту уже нет.
// Как мы можем это исправить? Один из вариантов обернуть метод в анонимную
// функцию, и вызвать в ней, тогда эта анонимная функция в своем лексическом
// окружении сохранит ссылку на объект, из которого наш метод будет вызываться:

// Вызов методов объекта через setTimeout и анонимную функцию.
// setTimeout(function () {
//     Roomba.startCleaning();
// }, 1000);  // I am cleaning... I have started: 1 times.

// setTimeout(function () {
//     Roomba.switchUVLamp();
// }, 2000); // UV lamp is not working.

// Сработало, но каждый раз оборачивать метод в анонимную функцию не очень
// удобно, есть способы лучше. Все они связаны с привязкой контекста (нужного нам
// объекта) во время вызова функции. Это уже знакомый нам метод call, а также еще
// два метода apply и bind.
// Метод call позволяет вызвать функцию и явно указать с каким объектом контекста
// её выполнить (передать в качестве первого аргумента объект, который будет
// доступен в функции через ключевое слово this). Давайте посмотрим на примере с
// пылесосом:


// Вызов метода объекта через call с явной передачей объекта
// робота-пылесоса в качестве контекста.
Roomba.startCleaning.call(Roomba); // I am cleaning... I have started: 1 times.
// Тут этот пример не очень показателен, т.к. Мы и так имели
// доступ к объекту, а внутри setTimeout использовать call возможно
// только обернув все это в анонимную функцию, но тоже бессмысленно,
// потому что тогда мы снова имеем доступ к объекту, как видели в
// прошлом примере. Но мы можем передать в call другой объект и
// увидеть что функция вызывается в контексте другого объекта:

// Создадим фиктивный объект робота, который содержит только одно
// свойство, необходимое для работы функции и сразу же зададим ему
// первоначальное значение, отличное от того, которое задано у
// робота, для наглядности.
const notARobot = {
    counterOfStarts: 10,
};
// вызываем
// Roomba.startCleaning.call(notARobot); // I am cleaning... I have been started: 11 times.

// Как мы видим, метод call позволил нам вызвать метод пользовательского объекта,
// но при этом указать в качестве контекста совсем другой объект и это сработало.
// Таким способом мы можем использовать метод call для вызова любой функции с
// нужным нам контекстом. Если вызываемая функция принимает аргументы, то их
// можно указать после объекта контекста, второй и все последующие аргументы
// метода call будут переданы как аргументы вызываемой функции.

// Подобно методу call можно использовать метод apply, который также позволяет
// вызвать функцию и передать необходимый контекст, единственным отличием от
// call, метод apply принимает аргументы, которые необходимо передать в
// вызываемую функцию не списком через запятую, а в виде массива, что порой
// удобнее. В нашем пример методы не принимают аргументов, но если бы
// принимали, это могло бы выглядеть вот так:

// Roomba.startCleaning.apply(notARobot, [arg1, arg2, arg3]); 

//     И последний метод для привязки контекста это bind (от английского bind -
//     связывать) - это самый часто используемый метод, т.к. позволяет привязать
//     контекст к функции раз и навсегда, и в дальнейшем мы можем просто вызывать
//     функции и быть уверены, что она будет вызвана в контексте нужного нам объекта.
//     Именно он поможет нам, чтобы починить наш алгоритм тестирования робота с
//     использованием setTimeout. Метод работает очень просто, его нужно вызвать для
//     необходимой нам функции и передать в него единственный аргумент - объект в
//     контексте которого мы хотим в дальнейшем вызывать нашу функцию, и наша
//     функция будет привязана к этому контексту навсегда.

// Вызов методов объекта.
// В setTimeout мы передаем не просто наш метод, а функцию,
// которая привязана к нашему объекту. Метод bind возвращает новую
// функцию, с уже привязанным контекстом, именно она вызывается по
// истечении времени.
// setTimeout(Roomba.startCleaning.bind(Roomba), 1000); // I am cleaning... I have been started:  2 times.
// setTimeout(Roomba.switchUVLamp.bind(Roomba), 2000);// UV lamp is not working.
// setTimeout(Roomba.goCharge.bind(Roomba), 3000); // I am going to charge...
setTimeout(Samba.startCleaning.bind(Samba), 1000)

// Все заработало как надо.