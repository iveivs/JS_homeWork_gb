// async/await
// Функционал async/await для работы с асинхронным кодом (а именно для работы с
// обещаниями) появился в JS с приходом стандарта ES7, и пока еще не слишком
// поддерживается браузерами, но есть полифилы для работы с ними.
// Суть подхода async/await - это писать асинхронный код так, будто он выполняется
// синхронно, но при этом не блокирует основной поток выполнения. Подход состоит
// из применения двух операторов:
// ● async - пишется перед функцией и превращает любую функцию в обещание, а
// также позволяет использовать второй оператор await внутри себя.
// ● await - оператор пишется перед вызовом асинхронной функции, что
// заставляет код остановиться в этом месте, пока асинхронная функция не
// вернет результат.
// Давайте посмотрим на пример:

const getUser = async (url) => {
    // Делаем запрос, и ждем его результат (указание await),
    // который будет сохранен в константу response.
    const response = await fetch(url);
    // Выполняем еще один асинхронный метод, преобразования в
    // текст, также ждем результат, который сохраняется в константупользователь.
    const user = await response.text();
    console.log(user);
}
getUser('https://api.github.com/users/octocat');
// Вывод в консоль.
// {
// "login": "octocat",
// "id": 583231,
// ...
// }
// Синтаксис async/await позволяет писать код очень линейно и чисто.

// “Запланированная асинхронность” -
// setTimeout, setInterval
// Бывают моменты, когда нам синхронный код превратить в асинхронный. Например
// мы не хотим делать запрос к серверу в тестовом приложении, а хотим просто
// имитировать задержку запросов, или вспомните самый первый пример из урока,
// там нам нужно было сгенерировать много дат, но при этом код был синхронным, и

// мы занимали весь поток так, что исполнение других сценариев на странице
// останавливалось. Вот в таких случаях нам может пригодится превращение
// синхронного кода в асинхронный, и сделать это можно с помощью функций
// setTimeout и setInterval, которые автоматически помещают функции обратного
// вызова в очередь отложенных задач, и которые будут выполняться асинхронно.
// Давайте возьмем наш первый пример с генерацией дат, и перепишем его так, чтобы
// он стал асинхронным и не блокировал основной поток:

const timerId = setInterval(() => {
    if (counter > amount) {
    // После того как наш счетчик достигнет нужного
    // количества итераций, мы должны очистить таймер, чтобы итерации
    // больше не выполнялись.
    clearInterval(timerId);
    console.log('End long calculations');
    }
    // Добавим вывод нашего счетчика через каждые 10000 итераций,
    // чтобы видеть что наш код работает.
    if (counter % 10000 === 0) {
    console.log('working: ', counter);
    }
    const newDate = new Date(counter);
    counter++;
    }, 0);
    // Start long calculations
    // working: 0
    // working: 10000
    // working: 20000
    // ...
    // End long calculations

//     Алгоритм выполняется значительно дольше, чем это было в синхронном коде,
// потому что каждая итерация представляет из себя целый набор действий, движку
// JavaScript необходимо создать функцию обратного вызова при каждой итерации,
// вызвать API среды выполнения (setInterval), которая поставит нашу функцию
// обратного вызова в очередь отложенных задач, после чего цикл событий должен
// дождаться когда стек вызовов будет пустым, и переместить функцию обратного
// вызова в стек вызовов, где она и будет исполнена. Зато такой код не блокирует
// страницу и можно выполнять другой код.

// Домашнее задание
// 1. "Получение данных о пользователе"
// Реализуйте функцию getUserData, которая принимает идентификатор
// пользователя (ID) в качестве аргумента и использует fetch для получения данных о
// пользователе с заданным ID с удаленного сервера. Функция должна возвращать
// промис, который разрешается с данными о пользователе в виде объекта. Если
// пользователь с указанным ID не найден, промис должен быть отклонен с
// соответствующим сообщением об ошибке.

// Подсказка, с последовательностью действий:
// getUserData использует fetch для получения данных о пользователе с
// удаленного сервера. Если запрос успешен (с кодом 200), функция извлекает
// данные из ответа с помощью response.json() и возвращает объект с данными о
// пользователе. Если запрос неуспешен, функция отклоняет промис с сообщением об
// ошибке.
//  - - - - -
// 2. "Отправка данных на сервер"
// Реализуйте функцию saveUserData, которая принимает объект с данными о
// пользователе в качестве аргумента и использует fetch для отправки этих данных
// на удаленный сервер для сохранения. Функция должна возвращать промис,
// который разрешается, если данные успешно отправлены, или отклоняется в случае
// ошибки.

Подсказка
// Пример использования функции
const user = {
    name: 'John Smith',
    age: 30,
    email: 'john@example.com'
};
saveUserData(user)
    .then(() => {
        console.log('User data saved successfully');
    })
    .catch(error => {
        console.log(error.message);
    });

// saveUserData использует fetch для отправки данных о пользователе на
// удаленный сервер для сохранения. Она отправляет POST-запрос на URL-адрес
// /users с указанием типа содержимого application/json и сериализует объект с
// данными о пользователе в JSON-строку с помощью JSON.stringify(). Если
// запрос успешен (с кодом 200), функция разрешает промис. Если запрос неуспешен,
// функция отклоняет промис с сообщением об ошибке.

// 3. "Изменение стиля элемента через заданное время"
// Напишите функцию changeStyleDelayed, которая принимает идентификатор
// элемента и время задержки (в миллисекундах) в качестве аргументов. Функция
// должна изменить стиль элемента через указанное время.
// Пример использования функции
changeStyleDelayed('myElement', 2000); // Через 2 секунды изменяет стиль элемента с id 'myElement'
